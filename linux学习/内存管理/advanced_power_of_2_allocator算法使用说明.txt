内存管理之2的幂次方分配器
1，简介
之前所描述的资源映射图分配器有诸多缺陷，因此这里引入另一个更有效的内存分配器—2的幂次方
分配器，2的幂次方分配器将内存块大小划分为2的幂次方，常用的尺寸有32，64，128，256，512，1024Byte,每页上只能包含有一种尺寸内存块。这样将不同尺寸的内存块管理起来，下次分配时先将请求的size
取整为2的幂次方，然后再去对应的空闲链表或位图中去查找空闲内存。
这种方法避免了资源映射图漫长的搜索过程，同时有利于减少内存碎片；但释放时不能部分释放，需要
将分配的大小都释放掉。
2的幂次方分配器根据管理方法的不同有多种实现方式，这里介绍以下2种：
1>  原始2的幂次方分配器
    最原始的2的幂次方分配器并不是每页上只含有一种尺寸的内存块，可以含有多种。内存块通过链表
    来管理，这样每个内存块的头部至少需要一个空间来保存指针，那么实际可用空间便少于2的幂次方

    表头数组
    -----
    |32 |—>(next,32)—>(next,32)—>(next,32)
    -----
    |64 |—>(next, 64)—>(next, 64)
    -----
    |128|—>(next,   128)—>(next,   128)
    -----
    |256|
    -----
    |512|
    -----
    对于这种方式，如果请求内存大小恰好为2的幂次方，假设为2^n，那么不得部分配一个2^(n+1)
    大小的内存块，内存浪费很严重。

2>  改进版
    要求每个页上只能存放一种尺寸的内存块，每个页的头部存放位图和指针来管理该页，空闲链表
    只需要将相关的页连接起来即可。页头部的指针free_list指向该页所属的空闲链表，next page
    为指向下一页的指针。我们暂将该区称为保留区。

    -------------------------
    |      位图             |
    |                       |
    -------------------------
    |    free_list(pointer) |
    -------------------------
    |    next page(pointer) |
    -------------------------
    |                       |
    |                       |
    |                       |
    |                       |
    |                       |
    |    可用内存           |
    |                       |
    |                       |
    |                       |
    |                       |
    |                       |
    |                       |
    |                       |
    -------------------------
    位图中相应位表示该页内存块的使用情况，为1表示相应内存块已分配，为0表示空闲。如果内存
    块的最小尺寸为32Byte,页大小为4096Byte,那么需要128位来保存位图。可用一个unsigned int型
    的4元素数组来保存。
    在寻找空闲内存块时先寻找有空闲块的页，通过比较位图数组的元素是否全为0xffffffff来判断该页
    是否有可用内存块，如果有，然后通过移位的方式快速定为是哪一位。这种寻找方式使得分配
    内存的速度变的很快。

    优点：内存分配速度快，可合并
    缺点：由于页头部保留区需要6*sizeof(unsigned int) = 24 Byte，剩余部分并不能全部划分为同一
    2的幂次方大小的内存块，因此会出现浪费。
    解决该浪费的方法是将保留区内容单独存放，但这需要另一个分配器来为这些内容开辟空间。
2，运行模拟程序
在编译连接时加入 -lm,文件中使用了数学运算函数。
运行结果如下：
-----------------------------------------------
jindizhao@jindizhao-Latitude-D520 ~/linux学习/内存管理 $ ./advanced_power_of_2_allocator 
请输入要分配的内存大小(<=512Byte),以空格分开，单位Byte, 按enter执行，按Ctrl+d结束模拟
12
allocated: start0x8f830d0 end0x8f830f0 size32
free:start 0x8f830d0  size 32
33
allocated: start0x8f850e0 end0x8f85120 size64
free:start 0x8f850e0  size 64
128
allocated: start0x8f870f0 end0x8f87170 size128
300
allocated: start0x8f8b110 end0x8f8b310 size512
72
allocated: start0x8f87170 end0x8f871f0 size128
15
allocated: start0x8f830d0 end0x8f830f0 size32
free:start 0x8f8b110  size 512
-----------------------------------------------
可以看出，请求12Byte时，分配了大小为32Byte的内存块，起始地址为0x8f830d0，之后又将其释放，
为了模拟真实情况，释放过程是随机的。
